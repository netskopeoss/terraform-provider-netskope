// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/netskope/terraform-provider-ns/internal/provider/types"
	"github.com/netskope/terraform-provider-ns/internal/sdk/models/shared"
)

func (r *NPAPrivateAppDataSourceModel) RefreshFromSharedPrivateAppsResponseData(resp *shared.PrivateAppsResponseData) {
	if resp != nil {
		r.AllowUnauthenticatedCors = types.BoolPointerValue(resp.AllowUnauthenticatedCors)
		r.AllowURIBypass = types.BoolPointerValue(resp.AllowURIBypass)
		if resp.AppOption == nil {
			r.AppOption = nil
		} else {
			r.AppOption = &tfTypes.AppOption{}
		}
		r.BypassUris = []types.String{}
		for _, v := range resp.BypassUris {
			r.BypassUris = append(r.BypassUris, types.StringValue(v))
		}
		r.ClientlessAccess = types.BoolPointerValue(resp.ClientlessAccess)
		r.Host = types.StringPointerValue(resp.Host)
		r.IsUserPortalApp = types.BoolPointerValue(resp.IsUserPortalApp)
		r.Name = types.StringPointerValue(resp.Name)
		if resp.PrivateAppID != nil {
			r.PrivateAppID = types.Int64Value(int64(*resp.PrivateAppID))
		} else {
			r.PrivateAppID = types.Int64Null()
		}
		r.Protocols = []tfTypes.ProtocolResponseItem{}
		if len(r.Protocols) > len(resp.Protocols) {
			r.Protocols = r.Protocols[:len(resp.Protocols)]
		}
		for protocolsCount, protocolsItem := range resp.Protocols {
			var protocols1 tfTypes.ProtocolResponseItem
			if protocolsItem.ID != nil {
				protocols1.ID = types.Int64Value(int64(*protocolsItem.ID))
			} else {
				protocols1.ID = types.Int64Null()
			}
			protocols1.Port = types.StringPointerValue(protocolsItem.Port)
			if protocolsItem.ServiceID != nil {
				protocols1.ServiceID = types.Int64Value(int64(*protocolsItem.ServiceID))
			} else {
				protocols1.ServiceID = types.Int64Null()
			}
			protocols1.Transport = types.StringPointerValue(protocolsItem.Transport)
			if protocolsCount+1 > len(r.Protocols) {
				r.Protocols = append(r.Protocols, protocols1)
			} else {
				r.Protocols[protocolsCount].ID = protocols1.ID
				r.Protocols[protocolsCount].Port = protocols1.Port
				r.Protocols[protocolsCount].ServiceID = protocols1.ServiceID
				r.Protocols[protocolsCount].Transport = protocols1.Transport
			}
		}
		r.RealHost = types.StringPointerValue(resp.RealHost)
		r.ServicePublisherAssignments = []tfTypes.ServicePublisherAssignmentItem{}
		if len(r.ServicePublisherAssignments) > len(resp.ServicePublisherAssignments) {
			r.ServicePublisherAssignments = r.ServicePublisherAssignments[:len(resp.ServicePublisherAssignments)]
		}
		for servicePublisherAssignmentsCount, servicePublisherAssignmentsItem := range resp.ServicePublisherAssignments {
			var servicePublisherAssignments1 tfTypes.ServicePublisherAssignmentItem
			servicePublisherAssignments1.Primary = types.BoolPointerValue(servicePublisherAssignmentsItem.Primary)
			if servicePublisherAssignmentsItem.PublisherID != nil {
				servicePublisherAssignments1.PublisherID = types.Int64Value(int64(*servicePublisherAssignmentsItem.PublisherID))
			} else {
				servicePublisherAssignments1.PublisherID = types.Int64Null()
			}
			if servicePublisherAssignmentsItem.Reachability == nil {
				servicePublisherAssignments1.Reachability = nil
			} else {
				servicePublisherAssignments1.Reachability = &tfTypes.Reachability{}
				if servicePublisherAssignmentsItem.Reachability.ErrorCode != nil {
					servicePublisherAssignments1.Reachability.ErrorCode = types.Int64Value(int64(*servicePublisherAssignmentsItem.Reachability.ErrorCode))
				} else {
					servicePublisherAssignments1.Reachability.ErrorCode = types.Int64Null()
				}
				servicePublisherAssignments1.Reachability.ErrorString = types.StringPointerValue(servicePublisherAssignmentsItem.Reachability.ErrorString)
				servicePublisherAssignments1.Reachability.Reachable = types.BoolPointerValue(servicePublisherAssignmentsItem.Reachability.Reachable)
			}
			if servicePublisherAssignmentsItem.ServiceID != nil {
				servicePublisherAssignments1.ServiceID = types.Int64Value(int64(*servicePublisherAssignmentsItem.ServiceID))
			} else {
				servicePublisherAssignments1.ServiceID = types.Int64Null()
			}
			if servicePublisherAssignmentsCount+1 > len(r.ServicePublisherAssignments) {
				r.ServicePublisherAssignments = append(r.ServicePublisherAssignments, servicePublisherAssignments1)
			} else {
				r.ServicePublisherAssignments[servicePublisherAssignmentsCount].Primary = servicePublisherAssignments1.Primary
				r.ServicePublisherAssignments[servicePublisherAssignmentsCount].PublisherID = servicePublisherAssignments1.PublisherID
				r.ServicePublisherAssignments[servicePublisherAssignmentsCount].Reachability = servicePublisherAssignments1.Reachability
				r.ServicePublisherAssignments[servicePublisherAssignmentsCount].ServiceID = servicePublisherAssignments1.ServiceID
			}
		}
		r.Tags = []tfTypes.TagItem{}
		if len(r.Tags) > len(resp.Tags) {
			r.Tags = r.Tags[:len(resp.Tags)]
		}
		for tagsCount, tagsItem := range resp.Tags {
			var tags1 tfTypes.TagItem
			if tagsItem.TagID != nil {
				tags1.TagID = types.Int64Value(int64(*tagsItem.TagID))
			} else {
				tags1.TagID = types.Int64Null()
			}
			tags1.TagName = types.StringPointerValue(tagsItem.TagName)
			if tagsCount+1 > len(r.Tags) {
				r.Tags = append(r.Tags, tags1)
			} else {
				r.Tags[tagsCount].TagID = tags1.TagID
				r.Tags[tagsCount].TagName = tags1.TagName
			}
		}
		r.TrustSelfSignedCerts = types.BoolPointerValue(resp.TrustSelfSignedCerts)
		r.UribypassHeaderValue = types.StringPointerValue(resp.UribypassHeaderValue)
		r.UsePublisherDNS = types.BoolPointerValue(resp.UsePublisherDNS)
	}
}
