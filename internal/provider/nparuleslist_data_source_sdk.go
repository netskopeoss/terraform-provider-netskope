// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/netskope/terraform-provider-ns/internal/provider/types"
	"github.com/netskope/terraform-provider-ns/internal/sdk/models/operations"
	"github.com/netskope/terraform-provider-ns/internal/sdk/models/shared"
)

func (r *NPARulesListDataSourceModel) RefreshFromSharedNpaPolicyResponseList(ctx context.Context, resp *shared.NpaPolicyResponseList) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Data = []tfTypes.NpaPolicyResponseItem{}
		if len(r.Data) > len(resp.Data) {
			r.Data = r.Data[:len(resp.Data)]
		}
		for dataCount, dataItem := range resp.Data {
			var data tfTypes.NpaPolicyResponseItem
			data.Enabled = types.StringPointerValue(dataItem.Enabled)
			data.GroupID = types.StringPointerValue(dataItem.GroupID)
			data.ModifyBy = types.StringPointerValue(dataItem.ModifyBy)
			data.ModifyTime = types.StringPointerValue(dataItem.ModifyTime)
			data.ModifyType = types.StringPointerValue(dataItem.ModifyType)
			data.PolicyType = types.StringPointerValue(dataItem.PolicyType)
			if dataItem.RuleData == nil {
				data.RuleData = nil
			} else {
				data.RuleData = &tfTypes.NpaPolicyRuleData{}
				data.RuleData.AccessMethod = make([]types.String, 0, len(dataItem.RuleData.AccessMethod))
				for _, v := range dataItem.RuleData.AccessMethod {
					data.RuleData.AccessMethod = append(data.RuleData.AccessMethod, types.StringValue(string(v)))
				}
				data.RuleData.BNegateNetLocation = types.BoolPointerValue(dataItem.RuleData.BNegateNetLocation)
				data.RuleData.BNegateSrcCountries = types.BoolPointerValue(dataItem.RuleData.BNegateSrcCountries)
				data.RuleData.Classification = types.StringPointerValue(dataItem.RuleData.Classification)
				data.RuleData.DeviceClassificationID = make([]types.Int64, 0, len(dataItem.RuleData.DeviceClassificationID))
				for _, v := range dataItem.RuleData.DeviceClassificationID {
					data.RuleData.DeviceClassificationID = append(data.RuleData.DeviceClassificationID, types.Int64Value(v))
				}
				data.RuleData.DlpActions = []tfTypes.NpaPolicyRuleDlp{}
				for dlpActionsCount, dlpActionsItem := range dataItem.RuleData.DlpActions {
					var dlpActions tfTypes.NpaPolicyRuleDlp
					dlpActions.Actions = make([]types.String, 0, len(dlpActionsItem.Actions))
					for _, v := range dlpActionsItem.Actions {
						dlpActions.Actions = append(dlpActions.Actions, types.StringValue(string(v)))
					}
					dlpActions.DlpProfile = types.StringPointerValue(dlpActionsItem.DlpProfile)
					if dlpActionsCount+1 > len(data.RuleData.DlpActions) {
						data.RuleData.DlpActions = append(data.RuleData.DlpActions, dlpActions)
					} else {
						data.RuleData.DlpActions[dlpActionsCount].Actions = dlpActions.Actions
						data.RuleData.DlpActions[dlpActionsCount].DlpProfile = dlpActions.DlpProfile
					}
				}
				data.RuleData.ExternalDlp = types.BoolPointerValue(dataItem.RuleData.ExternalDlp)
				data.RuleData.JSONVersion = types.Int64PointerValue(dataItem.RuleData.JSONVersion)
				if dataItem.RuleData.MatchCriteriaAction == nil {
					data.RuleData.MatchCriteriaAction = nil
				} else {
					data.RuleData.MatchCriteriaAction = &tfTypes.MatchCriteriaAction{}
					if dataItem.RuleData.MatchCriteriaAction.ActionName != nil {
						data.RuleData.MatchCriteriaAction.ActionName = types.StringValue(string(*dataItem.RuleData.MatchCriteriaAction.ActionName))
					} else {
						data.RuleData.MatchCriteriaAction.ActionName = types.StringNull()
					}
				}
				data.RuleData.NetLocationObj = make([]types.String, 0, len(dataItem.RuleData.NetLocationObj))
				for _, v := range dataItem.RuleData.NetLocationObj {
					data.RuleData.NetLocationObj = append(data.RuleData.NetLocationObj, types.StringValue(v))
				}
				data.RuleData.OrganizationUnits = make([]types.String, 0, len(dataItem.RuleData.OrganizationUnits))
				for _, v := range dataItem.RuleData.OrganizationUnits {
					data.RuleData.OrganizationUnits = append(data.RuleData.OrganizationUnits, types.StringValue(v))
				}
				if dataItem.RuleData.PolicyType != nil {
					data.RuleData.PolicyType = types.StringValue(string(*dataItem.RuleData.PolicyType))
				} else {
					data.RuleData.PolicyType = types.StringNull()
				}
				data.RuleData.PrivateApps = make([]types.String, 0, len(dataItem.RuleData.PrivateApps))
				for _, v := range dataItem.RuleData.PrivateApps {
					data.RuleData.PrivateApps = append(data.RuleData.PrivateApps, types.StringValue(v))
				}
				data.RuleData.PrivateAppsWithActivities = []tfTypes.PrivateAppsWithActivities{}
				for privateAppsWithActivitiesCount, privateAppsWithActivitiesItem := range dataItem.RuleData.PrivateAppsWithActivities {
					var privateAppsWithActivities tfTypes.PrivateAppsWithActivities
					privateAppsWithActivities.Activities = []tfTypes.Activities{}
					for activitiesCount, activitiesItem := range privateAppsWithActivitiesItem.Activities {
						var activities tfTypes.Activities
						if activitiesItem.Activity != nil {
							activities.Activity = types.StringValue(string(*activitiesItem.Activity))
						} else {
							activities.Activity = types.StringNull()
						}
						activities.ListOfConstraints = make([]types.String, 0, len(activitiesItem.ListOfConstraints))
						for _, v := range activitiesItem.ListOfConstraints {
							activities.ListOfConstraints = append(activities.ListOfConstraints, types.StringValue(v))
						}
						if activitiesCount+1 > len(privateAppsWithActivities.Activities) {
							privateAppsWithActivities.Activities = append(privateAppsWithActivities.Activities, activities)
						} else {
							privateAppsWithActivities.Activities[activitiesCount].Activity = activities.Activity
							privateAppsWithActivities.Activities[activitiesCount].ListOfConstraints = activities.ListOfConstraints
						}
					}
					privateAppsWithActivities.AppID = make([]types.String, 0, len(privateAppsWithActivitiesItem.AppID))
					for _, v := range privateAppsWithActivitiesItem.AppID {
						privateAppsWithActivities.AppID = append(privateAppsWithActivities.AppID, types.StringValue(v))
					}
					privateAppsWithActivities.AppName = types.StringPointerValue(privateAppsWithActivitiesItem.AppName)
					if privateAppsWithActivitiesCount+1 > len(data.RuleData.PrivateAppsWithActivities) {
						data.RuleData.PrivateAppsWithActivities = append(data.RuleData.PrivateAppsWithActivities, privateAppsWithActivities)
					} else {
						data.RuleData.PrivateAppsWithActivities[privateAppsWithActivitiesCount].Activities = privateAppsWithActivities.Activities
						data.RuleData.PrivateAppsWithActivities[privateAppsWithActivitiesCount].AppID = privateAppsWithActivities.AppID
						data.RuleData.PrivateAppsWithActivities[privateAppsWithActivitiesCount].AppName = privateAppsWithActivities.AppName
					}
				}
				data.RuleData.PrivateAppTagIds = make([]types.String, 0, len(dataItem.RuleData.PrivateAppTagIds))
				for _, v := range dataItem.RuleData.PrivateAppTagIds {
					data.RuleData.PrivateAppTagIds = append(data.RuleData.PrivateAppTagIds, types.StringValue(v))
				}
				data.RuleData.PrivateAppTags = make([]types.String, 0, len(dataItem.RuleData.PrivateAppTags))
				for _, v := range dataItem.RuleData.PrivateAppTags {
					data.RuleData.PrivateAppTags = append(data.RuleData.PrivateAppTags, types.StringValue(v))
				}
				data.RuleData.ShowDlpProfileActionTable = types.BoolPointerValue(dataItem.RuleData.ShowDlpProfileActionTable)
				data.RuleData.SrcCountries = make([]types.String, 0, len(dataItem.RuleData.SrcCountries))
				for _, v := range dataItem.RuleData.SrcCountries {
					data.RuleData.SrcCountries = append(data.RuleData.SrcCountries, types.StringValue(v))
				}
				data.RuleData.TssActions = []tfTypes.NpaPolicyRuleTss{}
				for tssActionsCount, tssActionsItem := range dataItem.RuleData.TssActions {
					var tssActions tfTypes.NpaPolicyRuleTss
					tssActions.Actions = []tfTypes.NpaPolicyRuleTssActions{}
					for actionsCount, actionsItem := range tssActionsItem.Actions {
						var actions tfTypes.NpaPolicyRuleTssActions
						if actionsItem.ActionName != nil {
							actions.ActionName = types.StringValue(string(*actionsItem.ActionName))
						} else {
							actions.ActionName = types.StringNull()
						}
						actions.RemediationProfile = types.StringPointerValue(actionsItem.RemediationProfile)
						if actionsItem.Severity != nil {
							actions.Severity = types.StringValue(string(*actionsItem.Severity))
						} else {
							actions.Severity = types.StringNull()
						}
						actions.Template = types.StringPointerValue(actionsItem.Template)
						if actionsCount+1 > len(tssActions.Actions) {
							tssActions.Actions = append(tssActions.Actions, actions)
						} else {
							tssActions.Actions[actionsCount].ActionName = actions.ActionName
							tssActions.Actions[actionsCount].RemediationProfile = actions.RemediationProfile
							tssActions.Actions[actionsCount].Severity = actions.Severity
							tssActions.Actions[actionsCount].Template = actions.Template
						}
					}
					tssActions.TssProfile = make([]types.String, 0, len(tssActionsItem.TssProfile))
					for _, v := range tssActionsItem.TssProfile {
						tssActions.TssProfile = append(tssActions.TssProfile, types.StringValue(v))
					}
					if tssActionsCount+1 > len(data.RuleData.TssActions) {
						data.RuleData.TssActions = append(data.RuleData.TssActions, tssActions)
					} else {
						data.RuleData.TssActions[tssActionsCount].Actions = tssActions.Actions
						data.RuleData.TssActions[tssActionsCount].TssProfile = tssActions.TssProfile
					}
				}
				data.RuleData.TssProfile = make([]types.String, 0, len(dataItem.RuleData.TssProfile))
				for _, v := range dataItem.RuleData.TssProfile {
					data.RuleData.TssProfile = append(data.RuleData.TssProfile, types.StringValue(v))
				}
				data.RuleData.UserGroups = make([]types.String, 0, len(dataItem.RuleData.UserGroups))
				for _, v := range dataItem.RuleData.UserGroups {
					data.RuleData.UserGroups = append(data.RuleData.UserGroups, types.StringValue(v))
				}
				data.RuleData.Users = make([]types.String, 0, len(dataItem.RuleData.Users))
				for _, v := range dataItem.RuleData.Users {
					data.RuleData.Users = append(data.RuleData.Users, types.StringValue(v))
				}
				if dataItem.RuleData.UserType != nil {
					data.RuleData.UserType = types.StringValue(string(*dataItem.RuleData.UserType))
				} else {
					data.RuleData.UserType = types.StringNull()
				}
				data.RuleData.Version = types.Int64PointerValue(dataItem.RuleData.Version)
			}
			data.RuleID = types.StringPointerValue(dataItem.RuleID)
			data.RuleName = types.StringPointerValue(dataItem.RuleName)
			if dataCount+1 > len(r.Data) {
				r.Data = append(r.Data, data)
			} else {
				r.Data[dataCount].Enabled = data.Enabled
				r.Data[dataCount].GroupID = data.GroupID
				r.Data[dataCount].ModifyBy = data.ModifyBy
				r.Data[dataCount].ModifyTime = data.ModifyTime
				r.Data[dataCount].ModifyType = data.ModifyType
				r.Data[dataCount].PolicyType = data.PolicyType
				r.Data[dataCount].RuleData = data.RuleData
				r.Data[dataCount].RuleID = data.RuleID
				r.Data[dataCount].RuleName = data.RuleName
			}
		}
	}

	return diags
}

func (r *NPARulesListDataSourceModel) ToOperationsGetNPARulesListRequest(ctx context.Context) (*operations.GetNPARulesListRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	filter := new(string)
	if !r.Filter.IsUnknown() && !r.Filter.IsNull() {
		*filter = r.Filter.ValueString()
	} else {
		filter = nil
	}
	limit := new(int64)
	if !r.Limit.IsUnknown() && !r.Limit.IsNull() {
		*limit = r.Limit.ValueInt64()
	} else {
		limit = nil
	}
	offset := new(int64)
	if !r.Offset.IsUnknown() && !r.Offset.IsNull() {
		*offset = r.Offset.ValueInt64()
	} else {
		offset = nil
	}
	sortby := new(string)
	if !r.Sortby.IsUnknown() && !r.Sortby.IsNull() {
		*sortby = r.Sortby.ValueString()
	} else {
		sortby = nil
	}
	sortorder := new(string)
	if !r.Sortorder.IsUnknown() && !r.Sortorder.IsNull() {
		*sortorder = r.Sortorder.ValueString()
	} else {
		sortorder = nil
	}
	out := operations.GetNPARulesListRequest{
		Filter:    filter,
		Limit:     limit,
		Offset:    offset,
		Sortby:    sortby,
		Sortorder: sortorder,
	}

	return &out, diags
}
